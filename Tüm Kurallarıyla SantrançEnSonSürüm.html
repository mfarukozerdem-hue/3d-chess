<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D SatranÃ§ Oyunu - Pro Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }
        
        /* Sol panel - oyun bilgileri ve kontroller */
        #leftPanel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 280px;
            color: white;
            z-index: 100;
            transition: transform 0.3s ease;
        }
        
        #leftPanel.hidden {
            transform: translateX(-320px);
        }
        
        #info {
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 15px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }
        
        #turn {
            font-size: 22px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .white-turn { 
            color: #f0f0f0;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .black-turn { 
            color: #888;
            text-shadow: 0 0 10px rgba(136, 136, 136, 0.5);
        }
        
        #moveCounter {
            text-align: center;
            font-size: 14px;
            color: #aaa;
            margin-bottom: 10px;
        }
        
        #controls {
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 15px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-btn {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        .control-btn:active {
            transform: translateY(0);
        }
        
        .control-btn:disabled {
            background: #555;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        .control-btn.ai-active {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        /* SaÄŸ panel - hamle geÃ§miÅŸi ve alÄ±nan taÅŸlar */
        #rightPanel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 280px;
            color: white;
            z-index: 100;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            transition: transform 0.3s ease;
        }
        
        #rightPanel.hidden {
            transform: translateX(320px);
        }
        
        #captured {
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 15px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .captured-section {
            margin-bottom: 15px;
        }
        
        .captured-title {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
            color: #aaa;
        }
        
        .captured-pieces {
            font-size: 24px;
            line-height: 1.5;
        }
        
        #moveHistory {
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            max-height: 400px;
            overflow-y: auto;
        }
        
        #moveHistory h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #aaa;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }
        
        .move-entry {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            transition: background 0.2s;
        }
        
        .move-entry:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .move-number {
            color: #667eea;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .move-notation {
            flex: 1;
        }
        
        .white-move {
            color: #f0f0f0;
        }
        
        .black-move {
            color: #aaa;
        }
        
        /* Toggle buttons */
        .toggle-btn {
            position: fixed;
            bottom: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            border: 2px solid rgba(102, 126, 234, 0.5);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            z-index: 101;
            transition: all 0.3s ease;
        }
        
        .toggle-btn:hover {
            background: rgba(102, 126, 234, 0.3);
            transform: translateY(-2px);
        }
        
        #leftToggle {
            left: 20px;
        }
        
        #rightToggle {
            right: 20px;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 30px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        /* Scrollbar styling */
        #rightPanel::-webkit-scrollbar,
        #moveHistory::-webkit-scrollbar {
            width: 8px;
        }
        
        #rightPanel::-webkit-scrollbar-track,
        #moveHistory::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        
        #rightPanel::-webkit-scrollbar-thumb,
        #moveHistory::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 10px;
        }
        
        #rightPanel::-webkit-scrollbar-thumb:hover,
        #moveHistory::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.7);
        }
    </style>
</head>
<body>
    <!-- Sol panel yapÄ±sÄ± -->
    <div id="leftPanel">
        <div id="info">
            <div id="turn" class="white-turn">Beyaz Oyuncunun SÄ±rasÄ±</div>
            <div id="moveCounter">Hamle: 1</div>
            <div style="font-size: 12px; color: #888; text-align: center;">
                Fare ile dÃ¶ndÃ¼r â€¢ Tekerlek ile zoom
            </div>
        </div>
        
        <div id="controls">
            <button class="control-btn" onclick="toggleAI()" id="aiBtn">ðŸ¤– AI ile Oyna</button>
            <button class="control-btn" onclick="undoMove()" id="undoBtn" disabled>â†¶ Geri Al</button>
            <button class="control-btn" onclick="newGame()">ðŸ”„ Yeni Oyun</button>
            <button class="control-btn" onclick="toggleSound()" id="soundBtn">ðŸ”Š Ses: AÃ§Ä±k</button>
            <button class="control-btn" onclick="saveGame()">ðŸ’¾ Kaydet</button>
            <button class="control-btn" onclick="loadGame()">ðŸ“‚ YÃ¼kle</button>
        </div>
    </div>
    
    <!-- SaÄŸ panel yapÄ±sÄ± -->
    <div id="rightPanel">
        <div id="captured">
            <div class="captured-section">
                <div class="captured-title">Beyaz AldÄ±:</div>
                <div class="captured-pieces" id="whiteCaptured">-</div>
            </div>
            <div class="captured-section">
                <div class="captured-title">Siyah AldÄ±:</div>
                <div class="captured-pieces" id="blackCaptured">-</div>
            </div>
        </div>
        
        <div id="moveHistory">
            <h3>ðŸ“œ Hamle GeÃ§miÅŸi</h3>
            <div id="moveList"></div>
        </div>
    </div>
    
    <!-- Toggle buttons -->
    <button id="leftToggle" class="toggle-btn" onclick="toggleLeftPanel()">â—€ Kapa</button>
    <button id="rightToggle" class="toggle-btn" onclick="toggleRightPanel()">Kapa â–¶</button>
    
    <div id="instructions">
        TaÅŸa tÄ±kla â†’ YeÅŸil: Gidebilir | KÄ±rmÄ±zÄ±: Yiyebilir
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        let soundEnabled = true;
        let aiEnabled = false;
        let leftPanelVisible = true;
        let rightPanelVisible = true;
        
        const sounds = {
            move: createSound(440, 0.1, 'sine'),
            capture: createSound(220, 0.15, 'square'),
            check: createSound(660, 0.2, 'triangle'),
            castle: createSound(330, 0.15, 'sine'),
            promote: createSound(880, 0.2, 'sine')
        };
        
        function createSound(frequency, duration, type = 'sine') {
            return { frequency, duration, type };
        }
        
        function playSound(sound) {
            if (!soundEnabled) return;
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = sound.frequency;
            oscillator.type = sound.type;
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + sound.duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + sound.duration);
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundBtn').textContent = soundEnabled ? 'ðŸ”Š Ses: AÃ§Ä±k' : 'ðŸ”‡ Ses: KapalÄ±';
        }
        
        function toggleAI() {
            aiEnabled = !aiEnabled;
            const btn = document.getElementById('aiBtn');
            if (aiEnabled) {
                btn.textContent = 'ðŸ¤– AI: Aktif';
                btn.classList.add('ai-active');
                if (currentTurn === 'black' && !gameOver) {
                    setTimeout(makeAIMove, 500);
                }
            } else {
                btn.textContent = 'ðŸ¤– AI ile Oyna';
                btn.classList.remove('ai-active');
            }
        }
        
        function toggleLeftPanel() {
            leftPanelVisible = !leftPanelVisible;
            const panel = document.getElementById('leftPanel');
            const btn = document.getElementById('leftToggle');
            if (leftPanelVisible) {
                panel.classList.remove('hidden');
                btn.textContent = 'â—€ Kapa';
            } else {
                panel.classList.add('hidden');
                btn.textContent = 'â–¶ AÃ§';
            }
        }
        
        function toggleRightPanel() {
            rightPanelVisible = !rightPanelVisible;
            const panel = document.getElementById('rightPanel');
            const btn = document.getElementById('rightToggle');
            if (rightPanelVisible) {
                panel.classList.remove('hidden');
                btn.textContent = 'Kapa â–¶';
            } else {
                panel.classList.add('hidden');
                btn.textContent = 'â—€ AÃ§';
            }
        }

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        scene.fog = new THREE.Fog(0x1a1a2e, 50, 100);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 25, 25);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 15;
        controls.maxDistance = 50;
        controls.maxPolarAngle = Math.PI / 2.2;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
        mainLight.position.set(10, 20, 10);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        mainLight.shadow.camera.near = 0.5;
        mainLight.shadow.camera.far = 50;
        mainLight.shadow.camera.left = -20;
        mainLight.shadow.camera.right = 20;
        mainLight.shadow.camera.top = 20;
        mainLight.shadow.camera.bottom = -20;
        scene.add(mainLight);

        const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
        fillLight.position.set(-10, 10, -10);
        scene.add(fillLight);

        const rimLight = new THREE.PointLight(0x667eea, 0.5);
        rimLight.position.set(0, 15, -15);
        scene.add(rimLight);

        const boardGroup = new THREE.Group();
        const squareSize = 2;
        const boardSize = 8;

        const labelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
        const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];
        
        // Tahta tabanÄ±
        const baseGeometry = new THREE.BoxGeometry(boardSize * squareSize + 1, 0.5, boardSize * squareSize + 1);
        const baseMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x3d2817,
            roughness: 0.7,
            metalness: 0.1
        });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = -0.25;
        base.receiveShadow = true;
        boardGroup.add(base);

        const squares = [];
        for (let row = 0; row < boardSize; row++) {
            squares[row] = [];
            for (let col = 0; col < boardSize; col++) {
                const isLight = (row + col) % 2 === 0;
                const squareGeometry = new THREE.BoxGeometry(squareSize, 0.1, squareSize);
                const squareMaterial = new THREE.MeshStandardMaterial({
                    color: isLight ? 0xf0d9b5 : 0xb58863,
                    roughness: 0.6,
                    metalness: 0.05
                });
                const square = new THREE.Mesh(squareGeometry, squareMaterial);
                square.position.set(
                    (col - 3.5) * squareSize,
                    0,
                    (row - 3.5) * squareSize
                );
                square.receiveShadow = true;
                square.userData = { row, col, isLight, originalColor: squareMaterial.color.getHex() };
                boardGroup.add(square);
                squares[row][col] = square;
            }
        }

        scene.add(boardGroup);

        function createPawn(color) {
            const group = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({
                color: color === 'white' ? 0xf5f5f5 : 0x1a1a1a,
                roughness: 0.3,
                metalness: 0.6,
                envMapIntensity: 1.0
            });

            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.45, 0.15, 32), material);
            base.position.y = 0.075;
            group.add(base);

            const lowerBody = new THREE.Mesh(new THREE.CylinderGeometry(0.28, 0.35, 0.3, 32), material);
            lowerBody.position.y = 0.3;
            group.add(lowerBody);

            const midBody = new THREE.Mesh(new THREE.SphereGeometry(0.25, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2), material);
            midBody.position.y = 0.5;
            midBody.scale.y = 1.2;
            group.add(midBody);

            const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.22, 0.25, 32), material);
            neck.position.y = 0.75;
            group.add(neck);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.32, 32, 32), material);
            head.position.y = 1.05;
            group.add(head);

            group.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            return group;
        }

        function createRook(color) {
            const group = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({
                color: color === 'white' ? 0xf5f5f5 : 0x1a1a1a,
                roughness: 0.3,
                metalness: 0.6,
                envMapIntensity: 1.0
            });

            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.55, 0.2, 32), material);
            base.position.y = 0.1;
            group.add(base);

            const ring1 = new THREE.Mesh(new THREE.TorusGeometry(0.4, 0.08, 16, 32), material);
            ring1.rotation.x = Math.PI / 2;
            ring1.position.y = 0.25;
            group.add(ring1);

            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.38, 0.4, 1.1, 32), material);
            body.position.y = 0.85;
            group.add(body);

            const ring2 = new THREE.Mesh(new THREE.TorusGeometry(0.35, 0.08, 16, 32), material);
            ring2.rotation.x = Math.PI / 2;
            ring2.position.y = 1.45;
            group.add(ring2);

            const top = new THREE.Mesh(new THREE.CylinderGeometry(0.42, 0.38, 0.25, 32), material);
            top.position.y = 1.65;
            group.add(top);

            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const merlon = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.35, 0.18), material);
                merlon.position.set(
                    Math.cos(angle) * 0.32,
                    1.95,
                    Math.sin(angle) * 0.32
                );
                group.add(merlon);
            }

            group.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            return group;
        }

        function createKnight(color) {
            const group = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({
                color: color === 'white' ? 0xf5f5f5 : 0x1a1a1a,
                roughness: 0.3,
                metalness: 0.6,
                envMapIntensity: 1.0
            });

            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.55, 0.2, 32), material);
            base.position.y = 0.1;
            group.add(base);

            const lowerBody = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.4, 0.4, 32), material);
            lowerBody.position.y = 0.4;
            group.add(lowerBody);

            const midBody = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.35, 0.5, 32), material);
            midBody.position.y = 0.85;
            group.add(midBody);

            const neckGeometry = new THREE.CylinderGeometry(0.22, 0.28, 0.4, 32);
            const neck = new THREE.Mesh(neckGeometry, material);
            neck.position.set(0.1, 1.25, 0);
            neck.rotation.z = -0.3;
            group.add(neck);

            const headGeometry = new THREE.BoxGeometry(0.45, 0.7, 0.55);
            const head = new THREE.Mesh(headGeometry, material);
            head.position.set(0.25, 1.6, 0.15);
            head.rotation.x = 0.2;
            head.rotation.z = -0.2;
            group.add(head);

            const snoutGeometry = new THREE.BoxGeometry(0.35, 0.35, 0.5);
            const snout = new THREE.Mesh(snoutGeometry, material);
            snout.position.set(0.3, 1.5, 0.5);
            snout.rotation.x = 0.3;
            group.add(snout);

            const ear1 = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.35, 16), material);
            ear1.position.set(0.1, 2.0, 0.1);
            ear1.rotation.z = -0.2;
            group.add(ear1);

            const ear2 = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.35, 16), material);
            ear2.position.set(0.4, 2.0, 0.1);
            ear2.rotation.z = 0.2;
            group.add(ear2);

            const eyeMaterial = new THREE.MeshStandardMaterial({
                color: color === 'white' ? 0x333333 : 0xcccccc,
                roughness: 0.1,
                metalness: 0.8
            });
            const eye = new THREE.Mesh(new THREE.SphereGeometry(0.06, 16, 16), eyeMaterial);
            eye.position.set(0.35, 1.7, 0.4);
            group.add(eye);

            for (let i = 0; i < 3; i++) {
                const mane = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.25, 0.1), material);
                mane.position.set(0.05 - i * 0.1, 1.8 - i * 0.15, -0.1);
                mane.rotation.z = 0.3;
                group.add(mane);
            }

            group.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            return group;
        }

        function createBishop(color) {
            const group = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({
                color: color === 'white' ? 0xf5f5f5 : 0x1a1a1a,
                roughness: 0.3,
                metalness: 0.6,
                envMapIntensity: 1.0
            });

            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.55, 0.2, 32), material);
            base.position.y = 0.1;
            group.add(base);

            const ring1 = new THREE.Mesh(new THREE.TorusGeometry(0.38, 0.08, 16, 32), material);
            ring1.rotation.x = Math.PI / 2;
            ring1.position.y = 0.25;
            group.add(ring1);

            const lowerBody = new THREE.Mesh(new THREE.CylinderGeometry(0.32, 0.38, 0.5, 32), material);
            lowerBody.position.y = 0.55;
            group.add(lowerBody);

            const midBody = new THREE.Mesh(new THREE.SphereGeometry(0.35, 32, 32, 0, Math.PI * 2, 0, Math.PI), material);
            midBody.position.y = 0.85;
            midBody.scale.y = 1.5;
            group.add(midBody);

            const upperBody = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.3, 0.6, 32), material);
            upperBody.position.y = 1.4;
            group.add(upperBody);

            const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.22, 0.3, 32), material);
            neck.position.y = 1.85;
            group.add(neck);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.38, 32, 32), material);
            head.position.y = 2.15;
            group.add(head);

            const slitMaterial = new THREE.MeshStandardMaterial({
                color: color === 'white' ? 0x333333 : 0xcccccc,
                roughness: 0.8,
                metalness: 0.2
            });
            const slit = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.3, 0.08), slitMaterial);
            slit.position.y = 2.5;
            group.add(slit);

            const topSphere = new THREE.Mesh(new THREE.SphereGeometry(0.15, 32, 32), material);
            topSphere.position.y = 2.7;
            group.add(topSphere);

            group.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            return group;
        }

        function createQueen(color) {
            const group = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({
                color: color === 'white' ? 0xf5f5f5 : 0x1a1a1a,
                roughness: 0.2,
                metalness: 0.7,
                envMapIntensity: 1.2
            });

            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 0.25, 32), material);
            base.position.y = 0.125;
            group.add(base);

            const ring1 = new THREE.Mesh(new THREE.TorusGeometry(0.45, 0.1, 16, 32), material);
            ring1.rotation.x = Math.PI / 2;
            ring1.position.y = 0.3;
            group.add(ring1);

            const lowerBody = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.45, 0.6, 32), material);
            lowerBody.position.y = 0.65;
            group.add(lowerBody);

            const midSphere = new THREE.Mesh(new THREE.SphereGeometry(0.38, 32, 32), material);
            midSphere.position.y = 1.05;
            midSphere.scale.y = 1.3;
            group.add(midSphere);

            const upperBody = new THREE.Mesh(new THREE.CylinderGeometry(0.28, 0.35, 0.7, 32), material);
            upperBody.position.y = 1.6;
            group.add(upperBody);

            const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.28, 0.25, 32), material);
            neck.position.y = 2.1;
            group.add(neck);

            const crownBase = new THREE.Mesh(new THREE.CylinderGeometry(0.38, 0.32, 0.35, 32), material);
            crownBase.position.y = 2.4;
            group.add(crownBase);

            const crownRing = new THREE.Mesh(new THREE.TorusGeometry(0.35, 0.08, 16, 32), material);
            crownRing.rotation.x = Math.PI / 2;
            crownRing.position.y = 2.6;
            group.add(crownRing);

            for (let i = 0; i < 9; i++) {
                const angle = (i / 9) * Math.PI * 2;
                const spike = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.4, 16), material);
                spike.position.set(
                    Math.cos(angle) * 0.32,
                    2.85,
                    Math.sin(angle) * 0.32
                );
                group.add(spike);
            }

            const orb = new THREE.Mesh(new THREE.SphereGeometry(0.14, 32, 32), material);
            orb.position.y = 3.1;
            group.add(orb);

            group.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            return group;
        }

        function createKing(color) {
            const group = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({
                color: color === 'white' ? 0xf5f5f5 : 0x1a1a1a,
                roughness: 0.2,
                metalness: 0.7,
                envMapIntensity: 1.2
            });

            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 0.25, 32), material);
            base.position.y = 0.125;
            group.add(base);

            const ring1 = new THREE.Mesh(new THREE.TorusGeometry(0.45, 0.1, 16, 32), material);
            ring1.rotation.x = Math.PI / 2;
            ring1.position.y = 0.3;
            group.add(ring1);

            const lowerBody = new THREE.Mesh(new THREE.CylinderGeometry(0.38, 0.45, 0.7, 32), material);
            lowerBody.position.y = 0.7;
            group.add(lowerBody);

            const midSphere = new THREE.Mesh(new THREE.SphereGeometry(0.4, 32, 32), material);
            midSphere.position.y = 1.15;
            midSphere.scale.y = 1.4;
            group.add(midSphere);

            const upperBody = new THREE.Mesh(new THREE.CylinderGeometry(0.32, 0.38, 0.8, 32), material);
            upperBody.position.y = 1.8;
            group.add(upperBody);

            const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.26, 0.32, 0.3, 32), material);
            neck.position.y = 2.35;
            group.add(neck);

            const crownBase = new THREE.Mesh(new THREE.CylinderGeometry(0.42, 0.36, 0.4, 32), material);
            crownBase.position.y = 2.7;
            group.add(crownBase);

            const crownRing = new THREE.Mesh(new THREE.TorusGeometry(0.38, 0.09, 16, 32), material);
            crownRing.rotation.x = Math.PI / 2;
            crownRing.position.y = 2.95;
            group.add(crownRing);

            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
                const spike = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.5, 16), material);
                spike.position.set(
                    Math.cos(angle) * 0.35,
                    3.25,
                    Math.sin(angle) * 0.35
                );
                group.add(spike);
            }

            const crossV = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.7, 0.12), material);
            crossV.position.y = 3.5;
            group.add(crossV);

            const crossH = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.12, 0.12), material);
            crossH.position.y = 3.4;
            group.add(crossH);

            const crossTop = new THREE.Mesh(new THREE.SphereGeometry(0.1, 32, 32), material);
            crossTop.position.y = 3.85;
            group.add(crossTop);

            group.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            return group;
        }

        const board = Array(8).fill(null).map(() => Array(8).fill(null));
        let selectedPiece = null;
        let currentTurn = 'white';
        const pieces = [];
        const moveIndicators = [];
        const capturedPieces = { white: [], black: [] };
        const castlingRights = {
            white: { kingSide: true, queenSide: true, kingMoved: false },
            black: { kingSide: true, queenSide: true, kingMoved: false }
        };
        let enPassantTarget = null;
        let gameOver = false;
        let checkStatus = { white: false, black: false };
        
        let moveHistory = [];
        let gameState = [];
        let moveNumber = 1;
        let lastMoveSquares = [];
        let animatingPiece = null;

        const pieceTypes = {
            'pawn': createPawn,
            'rook': createRook,
            'knight': createKnight,
            'bishop': createBishop,
            'queen': createQueen,
            'king': createKing
        };
        
        const pieceSymbols = {
            'king': 'K',
            'queen': 'Q',
            'rook': 'R',
            'bishop': 'B',
            'knight': 'N',
            'pawn': ''
        };
        
        const pieceValues = {
            'pawn': 100,
            'knight': 320,
            'bishop': 330,
            'rook': 500,
            'queen': 900,
            'king': 20000
        };
        
        const pawnPositionBonus = [
            [0,  0,  0,  0,  0,  0,  0,  0],
            [50, 50, 50, 50, 50, 50, 50, 50],
            [10, 10, 20, 30, 30, 20, 10, 10],
            [5,  5, 10, 25, 25, 10,  5,  5],
            [0,  0,  0, 20, 20,  0,  0,  0],
            [5, -5,-10,  0,  0,-10, -5,  5],
            [5, 10, 10,-20,-20, 10, 10,  5],
            [0,  0,  0,  0,  0,  0,  0,  0]
        ];
        
        function evaluateBoard() {
            let score = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (!piece) continue;
                    
                    let pieceValue = pieceValues[piece.userData.type];
                    
                    if (piece.userData.type === 'pawn') {
                        const bonusRow = piece.userData.color === 'white' ? row : 7 - row;
                        pieceValue += pawnPositionBonus[bonusRow][col];
                    }
                    
                    if (piece.userData.color === 'white') {
                        score += pieceValue;
                    } else {
                        score -= pieceValue;
                    }
                }
            }
            
            return score;
        }
        
        function minimax(depth, alpha, beta, maximizingPlayer) {
            if (depth === 0 || gameOver) {
                return evaluateBoard();
            }
            
            const color = maximizingPlayer ? 'black' : 'white';
            const allPieces = [];
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.userData.color === color) {
                        allPieces.push(piece);
                    }
                }
            }
            
            if (maximizingPlayer) {
                let maxEval = -Infinity;
                
                for (const piece of allPieces) {
                    const moves = getValidMoves(piece);
                    const fromRow = piece.userData.row;
                    const fromCol = piece.userData.col;
                    
                    for (const move of moves) {
                        const capturedPiece = board[move.row][move.col];
                        const oldRow = piece.userData.row;
                        const oldCol = piece.userData.col;
                        
                        board[fromRow][fromCol] = null;
                        board[move.row][move.col] = piece;
                        piece.userData.row = move.row;
                        piece.userData.col = move.col;
                        
                        const evaluation = minimax(depth - 1, alpha, beta, false);
                        
                        board[fromRow][fromCol] = piece;
                        board[move.row][move.col] = capturedPiece;
                        piece.userData.row = oldRow;
                        piece.userData.col = oldCol;
                        
                        maxEval = Math.max(maxEval, evaluation);
                        alpha = Math.max(alpha, evaluation);
                        
                        if (beta <= alpha) break;
                    }
                    if (beta <= alpha) break;
                }
                
                return maxEval;
            } else {
                let minEval = Infinity;
                
                for (const piece of allPieces) {
                    const moves = getValidMoves(piece);
                    const fromRow = piece.userData.row;
                    const fromCol = piece.userData.col;
                    
                    for (const move of moves) {
                        const capturedPiece = board[move.row][move.col];
                        const oldRow = piece.userData.row;
                        const oldCol = piece.userData.col;
                        
                        board[fromRow][fromCol] = null;
                        board[move.row][move.col] = piece;
                        piece.userData.row = move.row;
                        piece.userData.col = move.col;
                        
                        const evaluation = minimax(depth - 1, alpha, beta, true);
                        
                        board[fromRow][fromCol] = piece;
                        board[move.row][move.col] = capturedPiece;
                        piece.userData.row = oldRow;
                        piece.userData.col = oldCol;
                        
                        minEval = Math.min(minEval, evaluation);
                        beta = Math.min(beta, evaluation);
                        
                        if (beta <= alpha) break;
                    }
                    if (beta <= alpha) break;
                }
                
                return minEval;
            }
        }
        
        function makeAIMove() {
            if (!aiEnabled || currentTurn !== 'black' || gameOver || animatingPiece) return;
            
            let bestMove = null;
            let bestValue = -Infinity;
            
            const allPieces = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.userData.color === 'black') {
                        allPieces.push(piece);
                    }
                }
            }
            
            for (const piece of allPieces) {
                const moves = getValidMoves(piece);
                const fromRow = piece.userData.row;
                const fromCol = piece.userData.col;
                
                for (const move of moves) {
                    const capturedPiece = board[move.row][move.col];
                    const oldRow = piece.userData.row;
                    const oldCol = piece.userData.col;
                    
                    board[fromRow][fromCol] = null;
                    board[move.row][move.col] = piece;
                    piece.userData.row = move.row;
                    piece.userData.col = move.col;
                    
                    const moveValue = minimax(3, -Infinity, Infinity, false);
                    
                    board[fromRow][fromCol] = piece;
                    board[move.row][move.col] = capturedPiece;
                    piece.userData.row = oldRow;
                    piece.userData.col = oldCol;
                    
                    if (moveValue > bestValue) {
                        bestValue = moveValue;
                        bestMove = { piece, move, fromRow, fromCol };
                    }
                }
            }
            
            if (bestMove) {
                movePiece(bestMove.piece, bestMove.move.row, bestMove.move.col, bestMove.move);
            }
        }
        
        function squareToNotation(row, col) {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            return files[col] + (8 - row);
        }
        
        function addMoveToHistory(piece, fromRow, fromCol, toRow, toCol, captured, special = '') {
            const pieceSymbol = pieceSymbols[piece.userData.type];
            const from = squareToNotation(fromRow, fromCol);
            const to = squareToNotation(toRow, toCol);
            const captureSymbol = captured ? 'x' : '';
            
            let notation = '';
            if (special === 'O-O') {
                notation = 'O-O';
            } else if (special === 'O-O-O') {
                notation = 'O-O-O';
            } else {
                notation = pieceSymbol + (piece.userData.type === 'pawn' && captured ? from[0] : '') + captureSymbol + to;
                if (special === 'promotion') notation += '=Q';
                if (special === 'check') notation += '+';
                if (special === 'checkmate') notation += '#';
            }
            
            moveHistory.push({
                notation,
                color: piece.userData.color,
                moveNumber: piece.userData.color === 'white' ? moveNumber : moveNumber - 1
            });
            
            updateMoveHistoryDisplay();
        }
        
        function updateMoveHistoryDisplay() {
            const moveList = document.getElementById('moveList');
            moveList.innerHTML = '';
            
            for (let i = 0; i < moveHistory.length; i += 2) {
                const whiteMove = moveHistory[i];
                const blackMove = moveHistory[i + 1];
                
                const entry = document.createElement('div');
                entry.className = 'move-entry';
                
                const moveNum = document.createElement('span');
                moveNum.className = 'move-number';
                moveNum.textContent = whiteMove.moveNumber + '.';
                
                const notation = document.createElement('span');
                notation.className = 'move-notation';
                notation.innerHTML = `<span class="white-move">${whiteMove.notation}</span>` +
                    (blackMove ? ` <span class="black-move">${blackMove.notation}</span>` : '');
                
                entry.appendChild(moveNum);
                entry.appendChild(notation);
                moveList.appendChild(entry);
            }
            
            moveList.scrollTop = moveList.scrollHeight;
        }
        
        function highlightLastMove(fromRow, fromCol, toRow, toCol) {
            lastMoveSquares.forEach(sq => {
                sq.material.color.setHex(sq.userData.originalColor);
            });
            lastMoveSquares = [];
            
            const highlightColor = 0x7fb3d5;
            squares[fromRow][fromCol].material.color.setHex(highlightColor);
            squares[toRow][toCol].material.color.setHex(highlightColor);
            lastMoveSquares = [squares[fromRow][fromCol], squares[toRow][toCol]];
        }

        function createPiece(type, color, row, col) {
            const piece = pieceTypes[type](color);
            piece.userData = { type, color, row, col, hasMoved: false };
            piece.scale.y = 1.15;
            piece.position.set(
                (col - 3.5) * squareSize,
                0.1,
                (row - 3.5) * squareSize
            );
            scene.add(piece);
            pieces.push(piece);
            board[row][col] = piece;
            return piece;
        }

        function findKing(color) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.userData.type === 'king' && piece.userData.color === color) {
                        return { row, col, piece };
                    }
                }
            }
            return null;
        }

        function isSquareUnderAttack(row, col, byColor) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.userData.color === byColor) {
                        const moves = getValidMovesWithoutCheckValidation(piece);
                        if (moves.some(m => m.row === row && m.col === col)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function isKingInCheck(color) {
            const kingPos = findKing(color);
            if (!kingPos) return false;
            const opponentColor = color === 'white' ? 'black' : 'white';
            return isSquareUnderAttack(kingPos.row, kingPos.col, opponentColor);
        }

        function wouldMoveLeaveKingInCheck(piece, toRow, toCol) {
            const fromRow = piece.userData.row;
            const fromCol = piece.userData.col;
            const capturedPiece = board[toRow][toCol];
            
            board[fromRow][fromCol] = null;
            board[toRow][toCol] = piece;
            const originalRow = piece.userData.row;
            const originalCol = piece.userData.col;
            piece.userData.row = toRow;
            piece.userData.col = toCol;
            
            const inCheck = isKingInCheck(piece.userData.color);
            
            board[fromRow][fromCol] = piece;
            board[toRow][toCol] = capturedPiece;
            piece.userData.row = originalRow;
            piece.userData.col = originalCol;
            
            return inCheck;
        }

        function getValidMovesWithoutCheckValidation(piece) {
            const moves = [];
            const { type, color, row, col } = piece.userData;

            if (type === 'pawn') {
                const direction = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;
                
                if (row + direction >= 0 && row + direction < 8 && !board[row + direction][col]) {
                    moves.push({ row: row + direction, col, capture: false });
                    
                    if (row === startRow && !board[row + 2 * direction][col]) {
                        moves.push({ row: row + 2 * direction, col, capture: false, isDoubleMove: true });
                    }
                }
                
                for (let dc of [-1, 1]) {
                    const newCol = col + dc;
                    const newRow = row + direction;
                    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                        const target = board[newRow][newCol];
                        if (target && target.userData.color !== color) {
                            moves.push({ row: newRow, col: newCol, capture: true });
                        }
                        if (enPassantTarget && enPassantTarget.row === newRow && enPassantTarget.col === newCol) {
                            moves.push({ row: newRow, col: newCol, capture: true, isEnPassant: true });
                        }
                    }
                }
            } else if (type === 'rook') {
                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                for (let [dr, dc] of directions) {
                    for (let i = 1; i < 8; i++) {
                        const newRow = row + dr * i;
                        const newCol = col + dc * i;
                        if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                        
                        const target = board[newRow][newCol];
                        if (!target) {
                            moves.push({ row: newRow, col: newCol, capture: false });
                        } else {
                            if (target.userData.color !== color) {
                                moves.push({ row: newRow, col: newCol, capture: true });
                            }
                            break;
                        }
                    }
                }
            } else if (type === 'knight') {
                const knightMoves = [
                    [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                    [1, -2], [1, 2], [2, -1], [2, 1]
                ];
                for (let [dr, dc] of knightMoves) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                        const target = board[newRow][newCol];
                        if (!target) {
                            moves.push({ row: newRow, col: newCol, capture: false });
                        } else if (target.userData.color !== color) {
                            moves.push({ row: newRow, col: newCol, capture: true });
                        }
                    }
                }
            } else if (type === 'bishop') {
                const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                for (let [dr, dc] of directions) {
                    for (let i = 1; i < 8; i++) {
                        const newRow = row + dr * i;
                        const newCol = col + dc * i;
                        if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                        
                        const target = board[newRow][newCol];
                        if (!target) {
                            moves.push({ row: newRow, col: newCol, capture: false });
                        } else {
                            if (target.userData.color !== color) {
                                moves.push({ row: newRow, col: newCol, capture: true });
                            }
                            break;
                        }
                    }
                }
            } else if (type === 'queen') {
                const directions = [
                    [0, 1], [0, -1], [1, 0], [-1, 0],
                    [1, 1], [1, -1], [-1, 1], [-1, -1]
                ];
                for (let [dr, dc] of directions) {
                    for (let i = 1; i < 8; i++) {
                        const newRow = row + dr * i;
                        const newCol = col + dc * i;
                        if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                        
                        const target = board[newRow][newCol];
                        if (!target) {
                            moves.push({ row: newRow, col: newCol, capture: false });
                        } else {
                            if (target.userData.color !== color) {
                                moves.push({ row: newRow, col: newCol, capture: true });
                            }
                            break;
                        }
                    }
                }
            } else if (type === 'king') {
                const directions = [
                    [0, 1], [0, -1], [1, 0], [-1, 0],
                    [1, 1], [1, -1], [-1, 1], [-1, -1]
                ];
                for (let [dr, dc] of directions) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                        const target = board[newRow][newCol];
                        if (!target) {
                            moves.push({ row: newRow, col: newCol, capture: false });
                        } else if (target.userData.color !== color) {
                            moves.push({ row: newRow, col: newCol, capture: true });
                        }
                    }
                }
            }

            return moves;
        }

        function getCastlingMoves(piece) {
            const moves = [];
            const { color, row, col } = piece.userData;
            
            if (piece.userData.hasMoved || isKingInCheck(color)) {
                return moves;
            }
            
            const rights = castlingRights[color];
            const baseRow = color === 'white' ? 7 : 0;
            
            if (rights.kingSide && row === baseRow && col === 4) {
                const rook = board[baseRow][7];
                if (rook && rook.userData.type === 'rook' && !rook.userData.hasMoved) {
                    if (!board[baseRow][5] && !board[baseRow][6]) {
                        if (!isSquareUnderAttack(baseRow, 5, color === 'white' ? 'black' : 'white') &&
                            !isSquareUnderAttack(baseRow, 6, color === 'white' ? 'black' : 'white')) {
                            moves.push({ row: baseRow, col: 6, capture: false, isCastling: true, rookCol: 7 });
                        }
                    }
                }
            }
            
            if (rights.queenSide && row === baseRow && col === 4) {
                const rook = board[baseRow][0];
                if (rook && rook.userData.type === 'rook' && !rook.userData.hasMoved) {
                    if (!board[baseRow][1] && !board[baseRow][2] && !board[baseRow][3]) {
                        if (!isSquareUnderAttack(baseRow, 2, color === 'white' ? 'black' : 'white') &&
                            !isSquareUnderAttack(baseRow, 3, color === 'white' ? 'black' : 'white')) {
                            moves.push({ row: baseRow, col: 2, capture: false, isCastling: true, rookCol: 0 });
                        }
                    }
                }
            }
            
            return moves;
        }

        function getValidMoves(piece) {
            let moves = getValidMovesWithoutCheckValidation(piece);
            
            if (piece.userData.type === 'king') {
                moves = moves.concat(getCastlingMoves(piece));
            }
            
            moves = moves.filter(move => !wouldMoveLeaveKingInCheck(piece, move.row, move.col));
            
            return moves;
        }

        function setupBoard() {
            const backRow = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
            
            for (let col = 0; col < 8; col++) {
                createPiece(backRow[col], 'black', 0, col);
                createPiece('pawn', 'black', 1, col);
                createPiece('pawn', 'white', 6, col);
                createPiece(backRow[col], 'white', 7, col);
            }
        }

        function showMoveIndicators(moves) {
            clearMoveIndicators();
            
            moves.forEach(move => {
                const geometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
                const material = new THREE.MeshStandardMaterial({
                    color: move.capture ? 0xff4444 : 0x44ff44,
                    transparent: true,
                    opacity: 0.7,
                    emissive: move.capture ? 0xff0000 : 0x00ff00,
                    emissiveIntensity: 0.3
                });
                const indicator = new THREE.Mesh(geometry, material);
                indicator.position.set(
                    (move.col - 3.5) * squareSize,
                    0.2,
                    (move.row - 3.5) * squareSize
                );
                indicator.userData = { row: move.row, col: move.col, isIndicator: true, isCastling: move.isCastling, rookCol: move.rookCol, isEnPassant: move.isEnPassant };
                scene.add(indicator);
                moveIndicators.push(indicator);
            });
        }

        function clearMoveIndicators() {
            moveIndicators.forEach(indicator => scene.remove(indicator));
            moveIndicators.length = 0;
        }

        function showPromotionDialog(callback) {
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.95);
                padding: 30px;
                border-radius: 15px;
                z-index: 1000;
                text-align: center;
                border: 2px solid rgba(102, 126, 234, 0.5);
            `;
            
            const title = document.createElement('div');
            title.textContent = 'Piyon Terfisi - Bir taÅŸ seÃ§in:';
            title.style.cssText = 'color: white; font-size: 20px; margin-bottom: 20px;';
            dialog.appendChild(title);
            
            const pieces = [
                { type: 'queen', symbol: 'â™›', name: 'Vezir' },
                { type: 'rook', symbol: 'â™œ', name: 'Kale' },
                { type: 'bishop', symbol: 'â™', name: 'Fil' },
                { type: 'knight', symbol: 'â™ž', name: 'At' }
            ];
            
            pieces.forEach(p => {
                const btn = document.createElement('button');
                btn.textContent = `${p.symbol} ${p.name}`;
                btn.style.cssText = `
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    border: none;
                    padding: 15px 25px;
                    margin: 5px;
                    font-size: 18px;
                    cursor: pointer;
                    border-radius: 8px;
                    transition: transform 0.2s;
                `;
                btn.onmouseover = () => btn.style.transform = 'scale(1.05)';
                btn.onmouseout = () => btn.style.transform = 'scale(1)';
                btn.onclick = () => {
                    document.body.removeChild(dialog);
                    callback(p.type);
                };
                dialog.appendChild(btn);
            });
            
            document.body.appendChild(dialog);
        }

        function hasAnyValidMoves(color) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.userData.color === color) {
                        const moves = getValidMoves(piece);
                        if (moves.length > 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function showGameOver(message) {
            gameOver = true;
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            `;
            
            const messageBox = document.createElement('div');
            messageBox.style.cssText = `
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                padding: 50px;
                border-radius: 20px;
                text-align: center;
                font-size: 28px;
                font-weight: bold;
                color: white;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            `;
            messageBox.textContent = message;
            
            const restartBtn = document.createElement('button');
            restartBtn.textContent = 'ðŸ”„ Yeniden BaÅŸlat';
            restartBtn.style.cssText = `
                margin-top: 30px;
                background: white;
                color: #667eea;
                border: none;
                padding: 15px 40px;
                font-size: 18px;
                font-weight: bold;
                cursor: pointer;
                border-radius: 10px;
                transition: transform 0.2s;
            `;
            restartBtn.onmouseover = () => restartBtn.style.transform = 'scale(1.05)';
            restartBtn.onmouseout = () => restartBtn.style.transform = 'scale(1)';
            restartBtn.onclick = () => location.reload();
            
            messageBox.appendChild(document.createElement('br'));
            messageBox.appendChild(restartBtn);
            overlay.appendChild(messageBox);
            document.body.appendChild(overlay);
        }

        function animateMove(piece, targetX, targetZ, callback) {
            const startX = piece.position.x;
            const startZ = piece.position.z;
            const duration = 300;
            const startTime = Date.now();
            
            animatingPiece = piece;
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                piece.position.x = startX + (targetX - startX) * easeProgress;
                piece.position.z = startZ + (targetZ - startZ) * easeProgress;
                piece.position.y = 0.1 + Math.sin(progress * Math.PI) * 0.5;
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    piece.position.y = 0.1;
                    animatingPiece = null;
                    if (callback) callback();
                }
            }
            
            animate();
        }

        function movePiece(piece, newRow, newCol, moveData = {}) {
            const oldRow = piece.userData.row;
            const oldCol = piece.userData.col;
            let capturedPiece = null;
            let specialMove = '';
            
            saveGameState();
            
            if (moveData.isEnPassant) {
                const capturedPawnRow = piece.userData.color === 'white' ? newRow + 1 : newRow - 1;
                capturedPiece = board[capturedPawnRow][newCol];
                if (capturedPiece) {
                    scene.remove(capturedPiece);
                    pieces.splice(pieces.indexOf(capturedPiece), 1);
                    board[capturedPawnRow][newCol] = null;
                    capturedPieces[currentTurn].push('pawn');
                    playSound(sounds.capture);
                }
            }
            
            const targetPiece = board[newRow][newCol];
            if (targetPiece) {
                capturedPiece = targetPiece;
                scene.remove(targetPiece);
                pieces.splice(pieces.indexOf(targetPiece), 1);
                capturedPieces[currentTurn].push(targetPiece.userData.type);
                updateCapturedDisplay();
                playSound(sounds.capture);
            }
            
            if (moveData.isCastling) {
                const rook = board[newRow][moveData.rookCol];
                const newRookCol = newCol === 6 ? 5 : 3;
                board[newRow][moveData.rookCol] = null;
                board[newRow][newRookCol] = rook;
                rook.userData.col = newRookCol;
                rook.userData.hasMoved = true;
                
                const rookTargetX = (newRookCol - 3.5) * squareSize;
                const rookTargetZ = (newRow - 3.5) * squareSize;
                animateMove(rook, rookTargetX, rookTargetZ);
                
                specialMove = newCol === 6 ? 'O-O' : 'O-O-O';
                playSound(sounds.castle);
            } else if (!capturedPiece) {
                playSound(sounds.move);
            }
            
            board[oldRow][oldCol] = null;
            board[newRow][newCol] = piece;
            
            enPassantTarget = null;
            if (piece.userData.type === 'pawn' && moveData.isDoubleMove) {
                const direction = piece.userData.color === 'white' ? -1 : 1;
                enPassantTarget = { row: oldRow + direction, col: oldCol };
            }
            
            piece.userData.row = newRow;
            piece.userData.col = newCol;
            piece.userData.hasMoved = true;
            
            const targetX = (newCol - 3.5) * squareSize;
            const targetZ = (newRow - 3.5) * squareSize;
            
            animateMove(piece, targetX, targetZ, () => {
                if (piece.userData.type === 'pawn') {
                    const promotionRow = piece.userData.color === 'white' ? 0 : 7;
                    if (newRow === promotionRow) {
                        playSound(sounds.promote);
                        showPromotionDialog((newType) => {
                            scene.remove(piece);
                            pieces.splice(pieces.indexOf(piece), 1);
                            board[newRow][newCol] = null;
                            const promotedPiece = createPiece(newType, piece.userData.color, newRow, newCol);
                            promotedPiece.userData.hasMoved = true;
                            addMoveToHistory(piece, oldRow, oldCol, newRow, newCol, capturedPiece, 'promotion');
                            finishTurn();
                        });
                        return;
                    }
                }
                
                addMoveToHistory(piece, oldRow, oldCol, newRow, newCol, capturedPiece, specialMove);
                
                highlightLastMove(oldRow, oldCol, newRow, newCol);
                
                finishTurn();
            });
        }

        function finishTurn() {
            currentTurn = currentTurn === 'white' ? 'black' : 'white';
            
            if (currentTurn === 'white') {
                moveNumber++;
            }
            
            const inCheck = isKingInCheck(currentTurn);
            checkStatus[currentTurn] = inCheck;
            
            if (!hasAnyValidMoves(currentTurn)) {
                if (inCheck) {
                    const winner = currentTurn === 'white' ? 'Siyah' : 'Beyaz';
                    showGameOver(`ÅžAH MAT! ${winner} KazandÄ±!`);
                    if (moveHistory.length > 0) {
                        moveHistory[moveHistory.length - 1].notation += '#';
                        updateMoveHistoryDisplay();
                    }
                } else {
                    showGameOver('PAT! Oyun Berabere!');
                }
            } else if (inCheck) {
                playSound(sounds.check);
                updateTurnDisplay(' - ÅžAH!');
                if (moveHistory.length > 0) {
                    moveHistory[moveHistory.length - 1].notation += '+';
                    updateMoveHistoryDisplay();
                }
            } else {
                updateTurnDisplay();
            }
            
            document.getElementById('moveCounter').textContent = `Hamle: ${moveNumber}`;
            
            document.getElementById('undoBtn').disabled = gameState.length === 0;
            
            selectedPiece = null;
            clearMoveIndicators();
            
            if (aiEnabled && currentTurn === 'black' && !gameOver) {
                setTimeout(makeAIMove, 500);
            }
        }

        function updateTurnDisplay(suffix = '') {
            const turnElement = document.getElementById('turn');
            const turnText = currentTurn === 'white' ? 'Beyaz Oyuncunun SÄ±rasÄ±' : 'Siyah Oyuncunun SÄ±rasÄ±';
            turnElement.textContent = turnText + suffix;
            turnElement.className = currentTurn === 'white' ? 'white-turn' : 'black-turn';
        }

        function updateCapturedDisplay() {
            const pieceNames = {
                'pawn': 'â™Ÿ', 'rook': 'â™œ', 'knight': 'â™ž',
                'bishop': 'â™', 'queen': 'â™›', 'king': 'â™š'
            };
            
            document.getElementById('whiteCaptured').textContent = 
                capturedPieces.white.map(p => pieceNames[p]).join(' ') || '-';
            document.getElementById('blackCaptured').textContent = 
                capturedPieces.black.map(p => pieceNames[p]).join(' ') || '-';
        }
        
        function saveGameState() {
            const state = {
                board: board.map(row => row.map(piece => piece ? {
                    type: piece.userData.type,
                    color: piece.userData.color,
                    hasMoved: piece.userData.hasMoved
                } : null)),
                currentTurn,
                moveNumber,
                capturedPieces: JSON.parse(JSON.stringify(capturedPieces)),
                castlingRights: JSON.parse(JSON.stringify(castlingRights)),
                enPassantTarget: enPassantTarget ? { ...enPassantTarget } : null,
                moveHistory: [...moveHistory]
            };
            gameState.push(state);
        }
        
        function undoMove() {
            if (gameState.length === 0 || animatingPiece) return;
            
            const state = gameState.pop();
            
            pieces.forEach(piece => scene.remove(piece));
            pieces.length = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    board[row][col] = null;
                    const pieceData = state.board[row][col];
                    if (pieceData) {
                        const piece = createPiece(pieceData.type, pieceData.color, row, col);
                        piece.userData.hasMoved = pieceData.hasMoved;
                    }
                }
            }
            
            currentTurn = state.currentTurn;
            moveNumber = state.moveNumber;
            capturedPieces.white = [...state.capturedPieces.white];
            capturedPieces.black = [...state.capturedPieces.black];
            castlingRights.white = { ...state.castlingRights.white };
            castlingRights.black = { ...state.castlingRights.black };
            enPassantTarget = state.enPassantTarget ? { ...state.enPassantTarget } : null;
            moveHistory = [...state.moveHistory];
            
            updateTurnDisplay();
            updateCapturedDisplay();
            updateMoveHistoryDisplay();
            document.getElementById('moveCounter').textContent = `Hamle: ${moveNumber}`;
            document.getElementById('undoBtn').disabled = gameState.length === 0;
            
            lastMoveSquares.forEach(sq => {
                sq.material.color.setHex(sq.userData.originalColor);
            });
            lastMoveSquares = [];
            
            clearMoveIndicators();
            selectedPiece = null;
        }
        
        function newGame() {
            location.reload();
        }
        
        function saveGame() {
            const saveData = {
                board: board.map(row => row.map(piece => piece ? {
                    type: piece.userData.type,
                    color: piece.userData.color,
                    hasMoved: piece.userData.hasMoved,
                    row: piece.userData.row,
                    col: piece.userData.col
                } : null)),
                currentTurn,
                moveNumber,
                capturedPieces,
                castlingRights,
                enPassantTarget,
                moveHistory,
                gameState
            };
            
            localStorage.setItem('chessGameSave', JSON.stringify(saveData));
            alert('Oyun kaydedildi!');
        }
        
        function loadGame() {
            const saveData = localStorage.getItem('chessGameSave');
            if (!saveData) {
                alert('KaydedilmiÅŸ oyun bulunamadÄ±!');
                return;
            }
            
            const data = JSON.parse(saveData);
            
            pieces.forEach(piece => scene.remove(piece));
            pieces.length = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    board[row][col] = null;
                    const pieceData = data.board[row][col];
                    if (pieceData) {
                        const piece = createPiece(pieceData.type, pieceData.color, row, col);
                        piece.userData.hasMoved = pieceData.hasMoved;
                    }
                }
            }
            
            currentTurn = data.currentTurn;
            moveNumber = data.moveNumber;
            capturedPieces.white = [...data.capturedPieces.white];
            capturedPieces.black = [...data.capturedPieces.black];
            castlingRights.white = { ...data.castlingRights.white };
            castlingRights.black = { ...data.castlingRights.black };
            enPassantTarget = data.enPassantTarget ? { ...data.enPassantTarget } : null;
            moveHistory = [...data.moveHistory];
            gameState = data.gameState || [];
            
            updateTurnDisplay();
            updateCapturedDisplay();
            updateMoveHistoryDisplay();
            document.getElementById('moveCounter').textContent = `Hamle: ${moveNumber}`;
            document.getElementById('undoBtn').disabled = gameState.length === 0;
            
            alert('Oyun yÃ¼klendi!');
        }

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onMouseClick(event) {
            if (gameOver || animatingPiece || (aiEnabled && currentTurn === 'black')) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                let clickedObject = intersects[0].object;
                
                while (clickedObject.parent && !clickedObject.userData.type && !clickedObject.userData.isIndicator) {
                    clickedObject = clickedObject.parent;
                }

                if (clickedObject.userData.isIndicator && selectedPiece) {
                    const validMoves = getValidMoves(selectedPiece);
                    const moveData = validMoves.find(m => m.row === clickedObject.userData.row && m.col === clickedObject.userData.col);
                    movePiece(selectedPiece, clickedObject.userData.row, clickedObject.userData.col, moveData || {});
                    return;
                }

                if (clickedObject.userData.type) {
                    const piece = clickedObject;
                    
                    if (selectedPiece && piece.userData.color !== selectedPiece.userData.color) {
                        const validMoves = getValidMoves(selectedPiece);
                        const move = validMoves.find(m => m.row === piece.userData.row && m.col === piece.userData.col && m.capture);
                        if (move) {
                            movePiece(selectedPiece, piece.userData.row, piece.userData.col, move);
                            return;
                        }
                    }
                    
                    if (piece.userData.color === currentTurn) {
                        selectedPiece = piece;
                        const validMoves = getValidMoves(piece);
                        showMoveIndicators(validMoves);
                    }
                }
            } else {
                selectedPiece = null;
                clearMoveIndicators();
            }
        }

        window.addEventListener('click', onMouseClick);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        setupBoard();

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
